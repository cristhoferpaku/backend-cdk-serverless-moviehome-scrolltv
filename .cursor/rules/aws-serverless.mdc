---
description: 
globs: 
alwaysApply: false
---
eres un experto en serverless de aws con su cdk
Quiero que crees una arquitectura completa para un backend Serverless utilizando AWS CDK y TypeScript. Todas las funciones Lambda tambiÃ©n deben estar escritas en TypeScript.

---

### ðŸŽ¯ Objetivo:
Implementar un sistema modular y escalable que exponga endpoints REST a travÃ©s de API Gateway, utilizando funciones Lambda desacopladas, PostgreSQL como base de datos, y arquitectura limpia siguiendo los principios: handler â†’ service â†’ repository â†’ dto.

---

### ðŸ§± Estructura general esperada del proyecto:

BACKEND-CDK-SERVERLESS-MAXU/
â”œâ”€â”€ bin/
â”‚   â””â”€â”€ serverless-cdk.ts                # Punto de entrada principal del CDK
â”‚
â”œâ”€â”€ lib/
â”‚   â”œâ”€â”€ apigateway/
â”‚   â”‚   â”œâ”€â”€ add-api-methods.ts           # Agrega rutas y mÃ©todos a la API REST
â”‚   â”‚   â””â”€â”€ apigateway-stack.ts          # Define el API Gateway y sus integraciones
â”‚
â”‚   â”œâ”€â”€ certificates/                    # Comandos/documentaciÃ³n para configurar certificados ACM
â”‚   â”œâ”€â”€ route53/                         # Comandos/documentaciÃ³n para configurar dominios y HostedZones
â”‚
â”‚   â”œâ”€â”€ lambda/
â”‚   â”‚   â”œâ”€â”€ src/
â”‚   â”‚   â”‚   â””â”€â”€ functions/
â”‚   â”‚   â”‚       â””â”€â”€ getBillingDetail/
â”‚   â”‚   â”‚           â”œâ”€â”€ handler.ts
â”‚   â”‚   â”‚           â”œâ”€â”€ services/getBillingDetail.service.ts
â”‚   â”‚   â”‚           â”œâ”€â”€ repositories/getBillingDetail.repo.ts
â”‚   â”‚   â”‚           â””â”€â”€ dtos/getBillingDetail.dto.ts
â”‚   â”‚   â”‚
â”‚   â”‚   â”œâ”€â”€ layers/
â”‚   â”‚   â”‚   â”œâ”€â”€ pg/nodejs/dbConnector.ts
â”‚   â”‚   â”‚   â”œâ”€â”€ pg/nodejs/package.json
â”‚   â”‚   â”‚   â””â”€â”€ utils/nodejs/utils.ts
â”‚   â”‚   â”‚
â”‚   â”‚   â”œâ”€â”€ roles/
â”‚   â”‚   â”‚   â”œâ”€â”€ lambda-roles.ts
â”‚   â”‚   â”‚   â”œâ”€â”€ lambda-policies.ts
â”‚   â”‚   â”‚   â””â”€â”€ lambda-common-permissions.ts
â”‚   â”‚   â”‚
â”‚   â”‚   â”œâ”€â”€ helpers/
â”‚   â”‚   â”‚   â”œâ”€â”€ arn-functions.ts
â”‚   â”‚   â”‚   â””â”€â”€ add-api-methods.ts
â”‚   â”‚   â”œâ”€â”€ functions-template-lambda.ts
â”‚   â”‚   â”œâ”€â”€ lambda-functions-stack.ts
â”‚   â”‚   â”œâ”€â”€ lambda-layer-stack.ts
â”‚   â”‚   â””â”€â”€ lambda-role-stack.ts
â”‚
â”œâ”€â”€ layers/                               # (opcional si se separan fuera de lib)
â”œâ”€â”€ test/                                 # Pruebas unitarias
â”œâ”€â”€ cdk.json                              # Contexto CDK con datos por entorno (dev, prod, etc.)
â”œâ”€â”€ package.json
â”œâ”€â”€ package-lock.json
â”œâ”€â”€ tsconfig.json
â”œâ”€â”€ .gitignore
â””â”€â”€ README.md

---

### âš™ï¸ Infraestructura (CDK)

1. **serverless-cdk.ts**: entrypoint principal que instancia todos los stacks.
2. **functions-template-lambda.ts**: define funciones con `NodejsFunction` usando `esbuild`, con:
   - `minify: true`
   - `target: node20`
   - `externalModules`: ["pg", "aws-sdk", "moment-timezone"]
3. **lambda-functions-stack.ts**: crea todas las funciones usando las plantillas
4. **lambda-role-stack.ts**: define roles IAM por funciÃ³n
5. **apigateway-stack.ts**: crea el API REST y vincula funciones Lambda por ARN leÃ­do desde SSM
6. **arn-functions.ts**: contiene constantes con los nombres de parÃ¡metros en SSM (por ejemplo `/maxu/getBillingDetailFunction-arn`)

---

### ðŸ“¦ Lambda Layers

Crea dos layers reutilizables:

- `pgLayer`: contiene `pg`, `aws-sdk`, y un mÃ³dulo `dbConnector.ts` que obtiene las credenciales desde SSM y expone un pool de conexiones con mÃ©todos `query(...)` y `disconnect()`.
- `utilsLayer`: contiene `buildResponse(...)` y `logError(...)`, centralizados para toda la aplicaciÃ³n.

Las funciones Lambda importarÃ¡n esos mÃ³dulos desde `/opt/`.

---

### ðŸ§  PatrÃ³n interno de funciÃ³n Lambda

Cada funciÃ³n debe tener esta estructura y responsabilidades:

- `handler.ts`: recibe el evento y delega a la capa de servicios
- `services/*.service.ts`: contiene la lÃ³gica de negocio
- `repositories/*.repo.ts`: ejecuta las queries a PostgreSQL
- `dtos/*.dto.ts`: contiene tipos y validaciones (si aplica)

El handler debe importar desde los layers:
```ts
import db from '/opt/dbConnector';
import { buildResponse, logError } from '/opt/utils';


Para aÃ±adir una nueva funciÃ³n Lambda personalizada, se replicara la estructura siguiendo el patrÃ³n ya existente. ejemplo de una nueva funciÃ³n CustomFunction. AquÃ­ estÃ¡n las actualizaciones: 

// arn-functions.ts
static readonly CUSTOM_FUNCTION_ARN =
    "/maxu/custom-function-arn";


// function-template-lambda.ts
export const customTemplateLambda = (props: LambdaProps) => {
  const customFunctionLambda = new NodejsFunction(
    props.scope,
    "CustomFunction",
    {
      functionName: "CustomFunction",
      memorySize: 1024,
      timeout: Duration.seconds(30),
      runtime: Runtime.NODEJS_20_X,
      code: Code.fromAsset("lib/lambda/src/functions/custom"),
      handler: "handler.handler",
      role: props.lambdaRole,
      layers: [props.layerStack.utilsLayer, props.layerStack.pgLayer],
      bundling: {
        minify: true,
        externalModules: ["axios"],
      },
    }
  );

  new ssm.StringParameter(props.scope, "CustomFunctionArnParameter", {
    parameterName: ArnFunctions.CUSTOM_FUNCTION_ARN,
    stringValue: customFunctionLambda.functionArn,
  });

  return customFunctionLambda;
};


// lambda-functions-stack.ts
public readonly customFuncion: NodejsFunction;

this.customFuncion = customTemplateLambda({
  lambdaRole: props.lambdaRoles["CustomLambdaRole"],
  layerStack: props.layerStack,
  scope: this,
});


// lambda-roles.ts
{
  id: "CustomLambdaRole",
  assumedByService: "lambda.amazonaws.com",
  managedPolicies: ["service-role/AWSLambdaBasicExecutionRole"],
  policyStatements: [CloudWatchLogPermissions],
  additionalPolicies: ["SSMReadAccessPolicy"],
},


// add-api-methods.ts
const customFunction = ArnFunctions.getLambdaFunctionFromArn(
  scope,
  ArnFunctions.CUSTOM_FUNCTION_ARN,
  "ImportedCustomFunction"
);

addApiMethodsWithLambda({
  restApi,
  lambdaFunction: customFunction,
  authorizer,
  resourcePath: "tools/custom",
  methods: [
    {
      method: "POST",
      authorizationType: AuthorizationType.NONE,
      useAuthorizer: false,
      queryParameters: ["param1", "param2"],
    },
  ],
});

 


